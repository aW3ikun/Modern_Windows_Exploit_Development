## 0x0 Environment

`Win10 21h2`

`Windbg Preview`

## 0x1 Windbg

refer to other's blog that  《[Setting up kernel debugging using WinDbg and VMware](https://voidsec.com/windows-kernel-debugging-exploitation/)》。

- Setting symbol File Path

  Windbg Preview 

  File ->  Setting -> Debugging Settings->Symbol path 

  enter `SRV*d:\\pdb*http://msdl.microsoft.com/download/symbols`

### 0x11 symbol

| Command/Example                | **Description**                                              |
| ------------------------------ | ------------------------------------------------------------ |
| !wow64exts.sw                  | Switches between x86 and native mode.                        |
| .sympath+ c:\symbolpath        | append a symbol search path to the default one during debugging |
| .reload                        | reload the symbols                                           |
| x \*!\* / x kernel32!virtual\* | Checking Symbols                                             |
| ld*                            | load symbols for all modules                                 |
| .hh / .hh \<command\>          | get Help Or press F1                                         |

### 0x12 Modules

- Load an Executable or Attach to a Process

| Command                | Description                    |
| ---------------------- | ------------------------------ |
| lmf                    | list the loader module         |
| lmf m ntdll            | list a specifc module          |
| !dh ntdll/!dh 0x400000 | get the image header (PE Info) |

### 0x13 Expressions

use register, symbol ,value.

| Expressions                      | Description                      |
| -------------------------------- | -------------------------------- |
| bp 0x70000 / bp eip+1            | breakpoint                       |
| u ntdll!NtCommitTransaction+0x41 | use symbol to disassembly        |
| dd esp+4                         | use registers to Specifies value |

### 0x14 Numbers 

are by default in base 16.

|              |                                 |
| ------------ | ------------------------------- |
| 0x123        | base 16 (hexadecimal)           |
| 0n123        | base 10 (decimal)               |
| 0t123        | base 8 (octal)                  |
| 0y111        | base 2 (binary)                 |
| .formats     | display a value in mant formats |
| ?eax+4 /?4+4 | evaluate an expression          |

### 0x15 Pseudo-registers 

Pseudo-registers are indicated by the 
prefix ‘$‘. 

the prefix ‘@‘ which tells WinDbg that what follows is 
a register and not a symbol. If ‘@‘ is not used, WinDbg will first try to interpret the name as a symbol.

$teb or @$teb (address of the TEB) 
$peb or @$peb (address of the PEB) 
$thread or @$thread (current thread)

### 0x16 Exceptions

`Single-chance` means that the exception hasn’t been sent to the debuggee yet. 
When we resume the execution, WinDbg sends the exception to the debuggee. If the debuggee doesn’t 
handle the exception, WinDbg stops again and says that there’s been a `second-chance exception`



| Command                                                      | Description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| sxe / sex ld <module name 1>,...,<moudule name 2 N> / sxe ld user32 | break when a moudule is loaded                               |
| sx                                                           | list of exceptions type                                      |
| sxi / sxi ld /sxi sse                                        | ignore an exception \ ignore load module \ ignore single-chance single step exceptions |

### 0x17 Breakpoint

#### 0x171 sofrware brekpoint

When you put a software breakpoint on one instruction, WinDbg saves to memory the first byte of the 
instruction and overwrites it with 0xCC which is the opcode for “int 3“. 
When the “int 3” is executed, the breakpoint is triggered, the execution stops and WinDbg restores the 
instruction by restoring its first byte.

| Command           | Description                                                  |
| ----------------- | ------------------------------------------------------------ |
| bp 4110a3         | breakpoint at the address 0x4110a3                           |
| bp 4110a3 3       | breakpoint  ignored the first 2 times                        |
| g                 | resume the execution (go)                                    |
| g \<code location\> | run until a certain address <br>'g' puts a one-time software breakpoint. |

#### 0x172 hardware breakpoint

use specific registers of the CPU。

can’t set more than 4 breakpoints.

It’s not possible to use hardware breakpoints for a process

|                                                       |                                                              |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| ba \<mode\> \<size\> \<address\> <passes (default=1)> |                                                              |
| \<mode\>                                              | 'e'for execute <br/>'r'for read/write memory access <br/>'w' for write memory access |
| \<size\>                                              | specifies the size of the location, in bytes, to monitor for access (it’s always 1 when \<mode>\ is ‘e‘). |
| \<address\>                                           | the loction                                                  |
| \<passes\>                                            |                                                              |

#### 0x173 Handling Breakpoints

| Command | Description                |
| ------- | -------------------------- |
| bl      | breakpoint list            |
| bd      | disable a breakpoint       |
| bc      | delete a breakpoint        |
| bc *    | delete all the breakpoints |

```
0:016> bl
     0 e Disable Clear  04000000     0001 (0001)  0:**** uTools!v8_inspector::V8StackTraceId::IsInvalid+0x99b20
```

- 0 : breakpoint ID
- e : breakpoint status; can be (e)nabled or (d)isabled
- Disable : click Disable
- Clear : click Clear
- 04000000 : memory address 
- 0001(0001) : the number of passes
- 0:\****  : the associated process and thread. The asterisks mean that the breakpoint is not thread-
  specific
- uTools!v8_inspector::V8StackTraceId::IsInvalid+0x99b20 : the moudule, function and offset where the breakpoint is located

#### 0x174 Breakpoint Commands

example:

`bp Main ".echo \"Here are the registers:\n\"; r"`

```
Here are the registers:
eax=013b5f70 ebx=0117a000 ecx=00000001 edx=013b66e0 esi=00951023 edi=00951023
eip=00951810 esp=0133f9d0 ebp=0133f9ec iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
ConsoleApplication1!main:
00951810 55              push    ebp
```

`bp 00951811   ".printf \"new Array Data: addr = 0x%p\\n\",eax;g"`

```
new Array Data: addr = 0x013b5f70
```

### 0x18 Stepping

| Command           | Description                                        |
| ----------------- | -------------------------------------------------- |
| t                 | step-in                                            |
| p                 | step-over                                          |
| gu                | step-out                                           |
| pa/ta \<address\> | step/trace to address                              |
| pc/tc             | step/trace to next call/int instruction            |
| pt/tt             | step/trace to next ret (discussed above at point 3 |
| pct/tct           | step/trace to next call/int or ret                 |
| ph/th             | step/trace to next branching instruction           |

### 0x19 Memory

#### 0x191 Displaying Memory

| Command \ d* | Description                             |
| ------------ | --------------------------------------- |
| db           | display bytes                           |
| dw           | display words (2 bytes)                 |
| dd           | display dwords (4 bytes)                |
| dq           | display qwords (8 bytes)                |
| dyb          | display bits                            |
| da           | display null-terminated ASCII strings   |
| du           | display null-terminated Unicode strings |

**d* [range]**

| [range]                                 | Example                |
| --------------------------------------- | ---------------------- |
| \<start address> \<end address>         | db 77cac000 77cac0ff   |
| \<start address> L\<number of elements> | dd 77cac000  L10       |
| \<start address>                        | will display 128 bytes |

#### 0x192 Editing Memory

`e[d|w|b] <address> [<new value 1> ... <new value N>] `

d = dword, w = word, b = byte

`ed eip cc cc` This overwrites the first two dwords at the address in eip with the value 0xCC

#### 0x193 Searching Memory

`s [-d|-w|-b|-a|-u] <start address> L?<number of elements> <search values> `

### 0x1A Miscellaneous Commands 

#### 0x1A1 Pointer

`dd poi(ebp+4)`

#### 0x1A2 

| Command  | Description                   |
| -------- | ----------------------------- |
| r        | display the register          |
| u        | unassemble                    |
| u EIP L3 | print the first 3 instrutions |
| k        | display the call stack        |

#### 0x1A3 Dumping Structures
| Command  | Description                   |
| -------- | ----------------------------- |
| !teb  |  Displays the TEB (Thread Environment Block). |
| $teb  |  Address of the TEB. |
| !peb  |  Displays the PEB (Process Environment Block). |
| $peb  |  Address of the PEB. |
| !exchain  |  Displays the current exception handler chain. |
| !vadump  |  Displays the list of memory pages and info. |
| !lmi \<module name> |  Displays information for the specified module. |
| !slist \<address> ||
| [ \<symbol\> [\<offset\>] ] | Displays a singly-linked list, where: <br><address> is the address of the pointer to the first node of the list <br/><br/><br/><symbol> is the name of the structure of the nodes <br/><br/><offset> is the offset of the field “next” within the node |
| dt \<struct name> |  Displays the structure <struct name>. |
| dt \<struct name> \<field> | Displays the field <field> of the structure \<struct name>. |
| dt \<struct name> \<address\> |Displays the data at \<address> as a structure of type \<struct name\> (you needsymbols for \<struct name\>).|
| dg \<first selector>[\<last selector\>] |Displays the segment descriptor for the specified selectors.|



